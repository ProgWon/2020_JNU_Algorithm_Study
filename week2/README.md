# :heart_eyes: 문제를 풀며 배운점이나 공부한 점 등 자유롭게 기록 남기기 :heart_eyes:

## dhwhc0711

### [2234 성곽](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2234_dhwhc0711.cpp)
* 비트 마스킹에 대해서 알게 된 문제입니다. 처음에는 전연 변수로 선언해 & 연산을 사용해 풀었지만, (n & 1 << i(자릿수)) 로 해결이 가능하다는 것을 알고 적용시켜 봤습니다.
* 처음에는 DFS 를 사용하려 했으나, 방을 보이는대로 집어 넣어주기에는 BFS 가 조금 더 적절하다고 생각해 Queue 를 이용한 BFS 로 풀이했습니다.
* C++ 의 bitset 을 include 하여 10 진수를 2 진수로 바꿔줬습니다. 이후 굳이 2진수로 바꿔줄 필요 없이 AND 연산 이용하여 풀 수 있다는 점을 깨닫고 수정했습니다.
* 벽을 1칸 허물었을때의 최댓값의 경우는 무조건 최댓값과 그 다음 최댓값을 더한 값으로 될 줄 알았습니다. 하지만 벽이 떨어져있을 수 있다는 점을 깨닫고 수정했습니다.

### [2583 영역구하기](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2583_dhwhc0711.cpp)
* 촌수 계산 문제와 마찬가지로 check 배열을 굳이 사용할 필요가 없던 문제라고 생각했습니다.
* map이 1이 아닌 부분만 DFS 를 진행해주면 되므로 map 자체를 visited 로 사용해주었습니다.
* 밑에서부터 인덱스가 시작되어 어려움을 느꼈지만 생각해보니 위 아래를 바꾼다 해도 어차피 정렬을 해주기 때문에 상하 반전이 가능했습니다.
* 격자 이동시에 코드 내에서 장황하게 이동 방법을 구현하는것보다 전역 변수로 mx[4] = {0, 0, 1, -1}; 와 같이 선언해주고 더해주는 방법을 사용했습니다.

### [2644 촌수 계산](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2644_dhwhc0711.cpp)
* DFS, BFS 문제 풀이 할 때에 버릇처럼 항상 check 배열을 통한 방문 확인을 꼭 해주었는데, 이번 문제의 경우 방문 확인 대신 시작 지점의 node 에서의 거리를 표현한 dist 배열을 통해 대체하여 풀이 했습니다.
* DFS, BFS 복습을 위해 모든 방식으로 문제 풀이 해보았습니다. (DFS(stack, recursion), BFS(queue))

### 기록하고 싶은 내용
* 이번 기회에 DFS, BFS 를 많이 공부한 것 같습니다. 구현된 코드를 가지고 응용만 하다보니 가장 중요한 기본기가 모자랐던 점을 깨닫고 직접 전부 구현해보며 문제 풀이를 해보니 개념이 탄탄하게 잡히는 것을 느꼈습니다.
* 다시 한 번 복습하는 비트 연산 (아래 정도만 알면 알고리즘 풀이시에 문제 없을 듯?ㅎ)
  * AND (&) : 둘 다 1일 경우 1을 출력.
  * OR (|) : 하나라도 1일 경우 1을 출력.
  * XOR (^) : 두 비트가 다르면 1을 출력.
 
## spacein1001

### 2234 성곽

### 2583 영역구하기

### 2644 촌수 계산

### 기록하고 싶은 내용

## noble5712

### [2234 성곽](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2234_noble5712.java)
* 문제를 풀고 나니 불필요한 코드가 눈에 많이 들어왔습니다. Input 함수 내에서 String을 슬라이싱하여 뒤집어줬는데, 그럴 필요가 없었고, 벽을 부수는 과정에서 HashMap 을 사용했는데, 다른 풀이가 더 코드가 깔끔할 것 같아서 수정의 시간을 가질 예정입니다.

### [2583 영역구하기](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2583_noble5712.java)

### [2644 촌수 계산](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2644_noble5712.java)
* DFS, BFS 복습을 위해 모든 방식으로 풀이를 해보았습니다. (DFS 재귀, DFS 스택, BFS 큐)
* DFS는 주로 재귀로만 풀이하고 스택으로는 처음 풀이해보아서 앞으로 더욱 많은 연습이 필요하다고 느꼈습니다.

### 기록하고 싶은 내용
* ConcurrentModificationException(); 에러에 대해 알게 되었습니다.
  * 성곽 문제를 풀이하며 ArrayList의 길이를 참조하여 for문을 돌며 내부의 원소들을 비교하며 삭제하는 연산을 했는데, 이렇게 되면 for문의 인덱스가 계속 바뀌기 때문에 발생하는 에러였습니다.
  이러한 연산을 할 때, itrator를 사용해야한다는 점을 알게 되었습니다.
