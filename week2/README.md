# :heart_eyes: 문제를 풀며 배운점이나 공부한 점 등 자유롭게 기록 남기기 :heart_eyes:

## dhwhc0711

### [2234 성곽](https://www.acmicpc.net/problem/2234)
* 비트 마스킹에 대해서 알게 된 문제입니다. 처음에는 전연 변수로 선언해 & 연산을 사용해 풀었지만, (n & 1 << i(자릿수)) 로 해결이 가능하다는 것을 알고 적용시켜 봤습니다.
* 처음에는 DFS 를 사용하려 했으나, 방을 보이는대로 집어 넣어주기에는 BFS 가 조금 더 적절하다고 생각해 Queue 를 이용한 BFS 로 풀이했습니다.
* C++ 의 bitset 을 include 하여 10 진수를 2 진수로 바꿔줬습니다. 이후 굳이 2진수로 바꿔줄 필요 없이 AND 연산 이용하여 풀 수 있다는 점을 깨닫고 수정했습니다.
* 벽을 1칸 허물었을때의 최댓값의 경우는 무조건 최댓값과 그 다음 최댓값을 더한 값으로 될 줄 알았습니다. 하지만 벽이 떨어져있을 수 있다는 점을 깨닫고 수정했습니다.

### [2583 영역구하기](https://www.acmicpc.net/problem/2583)
* 촌수 계산 문제와 마찬가지로 check 배열을 굳이 사용할 필요가 없던 문제라고 생각했습니다.
* map이 1이 아닌 부분만 DFS 를 진행해주면 되므로 map 자체를 visited 로 사용해주었습니다.
* 밑에서부터 인덱스가 시작되어 어려움을 느꼈지만 생각해보니 위 아래를 바꾼다 해도 어차피 정렬을 해주기 때문에 상하 반전이 가능했습니다.
* 격자 이동시에 코드 내에서 장황하게 이동 방법을 구현하는것보다 전역 변수로 mx[4] = {0, 0, 1, -1}; 와 같이 선언해주고 더해주는 방법을 사용했습니다.

### [2644 촌수 계산](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2644_dhwhc0711.cpp)
* DFS, BFS 문제 풀이 할 때에 버릇처럼 항상 check 배열을 통한 방문 확인을 꼭 해주었는데, 이번 문제의 경우 방문 확인 대신 시작 지점의 node 에서의 거리를 표현한 dist 배열을 통해 대체하여 풀이 했습니다.
* DFS, BFS 복습을 위해 모든 방식으로 문제 풀이 해보았습니다. (DFS(stack, recursion), BFS(queue))

### 기록하고 싶은 내용
* 이번 기회에 DFS, BFS 를 많이 공부한 것 같습니다. 구현된 코드를 가지고 응용만 하다보니 가장 중요한 기본기가 모자랐던 점을 깨닫고 직접 전부 구현해보며 문제 풀이를 해보니 개념이 탄탄하게 잡히는 것을 느꼈습니다.
* 다시 한 번 복습하는 비트 연산 (아래 정도만 알면 알고리즘 풀이시에 문제 없을 듯?ㅎ)
  * AND (&) : 둘 다 1일 경우 1을 출력.
  * OR (|) : 하나라도 1일 경우 1을 출력.
  * XOR (^) : 두 비트가 다르면 1을 출력.
 
## spacein1001

### 2234 성곽

### 2583 영역구하기

### 2644 촌수 계산

### 기록하고 싶은 내용

## noble5712

### 2234 성곽

### 2583 영역구하기

### 2644 촌수 계산

### 기록하고 싶은 내용
