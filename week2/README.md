# :heart_eyes: 문제를 풀며 배운점이나 공부한 점 등 자유롭게 기록 남기기 :heart_eyes:

## dhwhc0711

### [2234 성곽](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2234_dhwhc0711.cpp)
* 비트 마스킹에 대해서 알게 된 문제입니다. 처음에는 전연 변수로 선언해 & 연산을 사용해 풀었지만, (n & 1 << i(자릿수)) 로 해결이 가능하다는 것을 알고 적용시켜 봤습니다.
* 처음에는 DFS 를 사용하려 했으나, 방을 보이는대로 집어 넣어주기에는 BFS 가 조금 더 적절하다고 생각해 Queue 를 이용한 BFS 로 풀이했습니다.
* C++ 의 bitset 을 include 하여 10 진수를 2 진수로 바꿔줬습니다. 이후 굳이 2진수로 바꿔줄 필요 없이 AND 연산 이용하여 풀 수 있다는 점을 깨닫고 수정했습니다.
* 벽을 1칸 허물었을때의 최댓값의 경우는 무조건 최댓값과 그 다음 최댓값을 더한 값으로 될 줄 알았습니다. 하지만 벽이 떨어져있을 수 있다는 점을 깨닫고 수정했습니다.

### [2583 영역구하기](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2583_dhwhc0711.cpp)
* 촌수 계산 문제와 마찬가지로 check 배열을 굳이 사용할 필요가 없던 문제라고 생각했습니다.
* map이 1이 아닌 부분만 DFS 를 진행해주면 되므로 map 자체를 visited 로 사용해주었습니다.
* 밑에서부터 인덱스가 시작되어 어려움을 느꼈지만 생각해보니 위 아래를 바꾼다 해도 어차피 정렬을 해주기 때문에 상하 반전이 가능했습니다.
* 격자 이동시에 코드 내에서 장황하게 이동 방법을 구현하는것보다 전역 변수로 mx[4] = {0, 0, 1, -1}; 와 같이 선언해주고 더해주는 방법을 사용했습니다.

### [2644 촌수 계산](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2644_dhwhc0711.cpp)
* DFS, BFS 문제 풀이 할 때에 버릇처럼 항상 check 배열을 통한 방문 확인을 꼭 해주었는데, 이번 문제의 경우 방문 확인 대신 시작 지점의 node 에서의 거리를 표현한 dist 배열을 통해 대체하여 풀이 했습니다.
* DFS, BFS 복습을 위해 모든 방식으로 문제 풀이 해보았습니다. (DFS(stack, recursion), BFS(queue))

### 기록하고 싶은 내용
* 이번 기회에 DFS, BFS 를 많이 공부한 것 같습니다. 구현된 코드를 가지고 응용만 하다보니 가장 중요한 기본기가 모자랐던 점을 깨닫고 직접 전부 구현해보며 문제 풀이를 해보니 개념이 탄탄하게 잡히는 것을 느꼈습니다.
* 다시 한 번 복습하는 비트 연산 (아래 정도만 알면 알고리즘 풀이시에 문제 없을 듯?ㅎ)
  * AND (&) : 둘 다 1일 경우 1을 출력.
  * OR (|) : 하나라도 1일 경우 1을 출력.
  * XOR (^) : 두 비트가 다르면 1을 출력.
 
## spacein1001

### [2234 성곽](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2234_spacein1001.java)
* 이 문제는 단순 BFS이긴하지만 입력값이 0과 1이 아닌 1~15값을 2진수로 바꾸어 벽이 없는 방향으로만 BFS를 적용시켜야하는 문제였습니다. 
* toBinaryString으로 2진수로 바꾸어 입력값을 저장했는데 함수구현을 잘 하지 못했고, 다른사람의 코드를 보고 적용시킨 풀이입니다.
* 재도전이 필요합니다. 비트마스킹과 비트연산자에 대한 공부가 필요합니다.

### [2583 영역구하기](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2583_spacein1001.java)
* 생각을 변화시키니 쉽게 푼 문제입니다. 문제를 그대로 받아들이기보다 코딩적 사고능력이 중요함을 깨달은 문제입니다.
* 문제에서는 x와 y좌표를 (x,y)로 두었지만 새로운 Point 클래스를 만들어 영역 한칸마다 (x,y)을 준다고 생각하여 풀었습니다.
* 객체를 더 능숙하게 사용하게 만들어준 문제이기 때문에 종종 볼 것 같은 코드입니다.

### [2644 촌수 계산](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2644_spacein1001.java)
* 백준 BFS 문제중 2606번인 바이러스 문제와 매우 유사해서 쉽게 푼 문제입니다. 
* 다른 점이라고는 BFS에 cost라는 배열을 만들어 BFS가 새로운 칸을 검사할 때마다 값을 저장해 두었습니다.

### 기록하고 싶은 내용

## noble5712

### [2234 성곽](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2234_noble5712.java)
* 문제를 풀고 나니 불필요한 코드가 눈에 많이 들어왔습니다. 
  * 이론을 배우면 시간복잡도에서 N의 제곱항만 고려하고 상수항은 무시하지만 실제로 프로그램을 돌리면 N^2의 반복문이 여러개있으면 수행시간이 더 걸릴 것이라고 생각해서 한개의 이중 for문 내에서 모두 해결하려고 하는 과정에서 코드가 복잡해진 것 같습니다.
  * Input 함수 내에서 String을 슬라이싱하여 뒤집어줬는데 그럴 필요 없이 더 간결하게 할 수 있었습니다.
  * 벽을 부수는 과정에서 HashMap 을 사용했는데, 다른 풀이가 더 코드가 깔끔할 것 같아서 수정의 시간을 가질 예정입니다.
* 방의 갯수를 세는 과정에서 출발지부터의 거리와 실제적인 방의 거리와는 차이가 있음을 인지하고 어느 단계에서 카운트를 증가시켜주느냐에 따라 다른 결과가 나옴을 확실하게 알게 되었습니다.

### [2583 영역구하기](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2583_noble5712.java)
* 2차원 인접 행렬을 탐색할때 X,Y 인덱스에 대한 생각이 필요했던 문제 였던거 같습니다. 그외에는 특이사항이 없습니다.

### [2644 촌수 계산](https://github.com/ProgWon/2020_JNU_Algorithm_Study/blob/main/week2/2644_noble5712.java)
* DFS, BFS 복습을 위해 모든 방식으로 풀이를 해보았습니다. (DFS 재귀, DFS 스택, BFS 큐)
* DFS는 주로 재귀로만 풀이하고 스택으로는 처음 풀이해보아서 앞으로 더욱 많은 연습이 필요하다고 느꼈습니다.

### 기록하고 싶은 내용
* ConcurrentModificationException(); 에러에 대해 알게 되었습니다.
  * 성곽 문제를 풀이하며 ArrayList의 길이를 참조하여 for문을 돌며 내부의 원소들을 비교하며 삭제하는 연산을 했는데, 이렇게 되면 for문의 인덱스가 계속 바뀌기 때문에 발생하는 에러였습니다.
  이러한 연산을 할 때, iterator를 사용해야한다는 점을 알게 되었습니다.
* (도전과제)비트 마스킹에 대한 공부, ArrayList에 대한 궁금점을 해결해야 함.
